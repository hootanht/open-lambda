# start the websocket gateway

1. Copy all 3 folders under 'test-registry/websocket_chat' to 'default-ol/registry'. 

  I am very willing to deploy a websocket app under a separate folder, namely copy '/websocket_chat' to 'default-ol/registry/websocket_chat', instead of copying '/websocket_chat/onConnect', '/websocket_chat/onDisconnect' and '/websocket_chat/onMessage' to 'default-ol/registry'. But it seems current implementation does not support this, as described in src\worker\lambda\code_puller.md: 
> **Local:** If `registry` is a path to a directory in the local file
> system, then lambdas may be represented as a (1) a standalone .py
> file, (2) a .tar.gz containing a f.py file, or (3) a
> directory containing a f.py file.  If `registry` is
> `/var/local/registry` and a lambda named `runme` is being pulled,
> the worker will check for these resources (in this order): 
> 1. file named /var/local/registry/runme.tar.gz
> 2. file named /var/local/registry/runme.py
> 3. dir named /var/local/registry/runme

2. modify the python code in onConnect, onDisconnect and onMessage. 

Knowing the websocket connection id is very important for websocket app, check the example code in 'websocket_chat' folder to understand why. 

Storing websocket connection ids in database provide more flexibility for user. However, you need to change `redis_host`, `redis_port`, `redis_username` and `redis_password` in the python files according to your own redis server. Of course, you can also change the code to use other database, such as mysql, mongodb, etc.

3. Start the websocket gateway
```bash
./ol websocket-api
```
4. Connect to the websocket gateway, by default it is listening on port 4999.
```bash
wscat -c ws://localhost:4999/ws
```
3. send a packet contains Action, Target and Body fields, for example:
```json
{
    "Action": "run",
    "Target": "sendMsg",
    "Body": {"hello": "world"}
}
```
For now, "Action" can only be "run", pub/sub action might be added in the future. 
"Target" is the name of the lambda function you want to call. 
"Body" is the data you want to pass to the lambda function.

4. A packet will be sent to the lambda function with the following format:
```json
{
    "Context": {"id":"123456789"}, // "123456789" is the sample id of the websocket connection
    "Body": {"hello": "world"}
}
```
Body is the data you passed in step 3. Context is generated by the websocket gateway, for now it only contains the sender's id.

You may parse the passed-in arg `event` to get these data.
```python
def f(event):
    print(event["Context"]["id"])
    print(event["Body"]["hello"])
```

Tests:
functionality test:
1. test connection id correctly add to database and returned to client
2. test send message to a specific connection with given connection id
2. test concurrent write to one websocket connection
3. test connection id correctly deleted from database when connection closed

Performance test:
1. test throughput